
/**
 * Autogenerated by Jack
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
/* generated from migration version 20111112181520 */
package javadb.timely.database_1.mock_impl;

import java.util.Arrays;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.io.IOException;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Date;
import java.sql.Timestamp;

import com.rapleaf.jack.AbstractMockDatabaseModel;
import com.rapleaf.jack.ModelWithId;

import javadb.timely.database_1.models.Person;
import javadb.timely.database_1.iface.IPersonPersistence;

import javadb.timely.IDatabases;

public class BaseMockPersonPersistenceImpl extends AbstractMockDatabaseModel<Person> implements IPersonPersistence {
  private final IDatabases databases;

  private static AtomicInteger curId = new AtomicInteger(1);

  public BaseMockPersonPersistenceImpl(IDatabases databases) {
    super();
    this.databases = databases;
  }

  @Override
  public ModelWithId create(Map<Enum, Object> fieldsMap) throws IOException {
    String remember_token = (String) fieldsMap.get(Person._Fields.remember_token);
    Long remember_created_at = (Long) fieldsMap.get(Person._Fields.remember_created_at);
    Integer sign_in_count_tmp = (Integer) fieldsMap.get(Person._Fields.sign_in_count);
    Integer sign_in_count = sign_in_count_tmp == null ? 0 : sign_in_count_tmp;
    Long current_sign_in_at = (Long) fieldsMap.get(Person._Fields.current_sign_in_at);
    Long last_sign_in_at = (Long) fieldsMap.get(Person._Fields.last_sign_in_at);
    String current_sign_in_ip = (String) fieldsMap.get(Person._Fields.current_sign_in_ip);
    String last_sign_in_ip = (String) fieldsMap.get(Person._Fields.last_sign_in_ip);
    String authentication_token = (String) fieldsMap.get(Person._Fields.authentication_token);
    String email = (String) fieldsMap.get(Person._Fields.email);
    String private_email = (String) fieldsMap.get(Person._Fields.private_email);
    String phone = (String) fieldsMap.get(Person._Fields.phone);
    String firstname = (String) fieldsMap.get(Person._Fields.firstname);
    String lastname = (String) fieldsMap.get(Person._Fields.lastname);
    String type = (String) fieldsMap.get(Person._Fields.type);
    Long created_at = (Long) fieldsMap.get(Person._Fields.created_at);
    Long updated_at = (Long) fieldsMap.get(Person._Fields.updated_at);
    return create(remember_token, remember_created_at, sign_in_count, current_sign_in_at, last_sign_in_at, current_sign_in_ip, last_sign_in_ip, authentication_token, email, private_email, phone, firstname, lastname, type, created_at, updated_at);
  }


  public Person create(final String remember_token, final Long remember_created_at, final Integer sign_in_count, final Long current_sign_in_at, final Long last_sign_in_at, final String current_sign_in_ip, final String last_sign_in_ip, final String authentication_token, final String email, final String private_email, final String phone, final String firstname, final String lastname, final String type, final Long created_at, final Long updated_at) throws IOException {
    long __id = curId.getAndIncrement();
    Person newInst = new Person(__id, remember_token, remember_created_at, sign_in_count, current_sign_in_at, last_sign_in_at, current_sign_in_ip, last_sign_in_ip, authentication_token, email, private_email, phone, firstname, lastname, type, created_at, updated_at, databases);
    records.put(__id, newInst);
    clearForeignKeyCache();
    return newInst;
  }


  public Set<Person> find(Map<Enum, Object> fieldsMap) throws IOException {
    return super.realFind(fieldsMap);
  }

  public Set<Person> find(Set<Long> ids, Map<Enum, Object> fieldsMap) throws IOException {
    return super.realFind(ids, fieldsMap);
  }

  public Set<Person> findByRememberToken(final String value) throws IOException {
    return find(new HashMap<Enum, Object>(){{put(Person._Fields.remember_token, value);}});
  }

  public Set<Person> findByRememberCreatedAt(final Long value) throws IOException {
    return find(new HashMap<Enum, Object>(){{put(Person._Fields.remember_created_at, value);}});
  }

  public Set<Person> findBySignInCount(final Integer value) throws IOException {
    return find(new HashMap<Enum, Object>(){{put(Person._Fields.sign_in_count, value);}});
  }

  public Set<Person> findByCurrentSignInAt(final Long value) throws IOException {
    return find(new HashMap<Enum, Object>(){{put(Person._Fields.current_sign_in_at, value);}});
  }

  public Set<Person> findByLastSignInAt(final Long value) throws IOException {
    return find(new HashMap<Enum, Object>(){{put(Person._Fields.last_sign_in_at, value);}});
  }

  public Set<Person> findByCurrentSignInIp(final String value) throws IOException {
    return find(new HashMap<Enum, Object>(){{put(Person._Fields.current_sign_in_ip, value);}});
  }

  public Set<Person> findByLastSignInIp(final String value) throws IOException {
    return find(new HashMap<Enum, Object>(){{put(Person._Fields.last_sign_in_ip, value);}});
  }

  public Set<Person> findByAuthenticationToken(final String value) throws IOException {
    return find(new HashMap<Enum, Object>(){{put(Person._Fields.authentication_token, value);}});
  }

  public Set<Person> findByEmail(final String value) throws IOException {
    return find(new HashMap<Enum, Object>(){{put(Person._Fields.email, value);}});
  }

  public Set<Person> findByPrivateEmail(final String value) throws IOException {
    return find(new HashMap<Enum, Object>(){{put(Person._Fields.private_email, value);}});
  }

  public Set<Person> findByPhone(final String value) throws IOException {
    return find(new HashMap<Enum, Object>(){{put(Person._Fields.phone, value);}});
  }

  public Set<Person> findByFirstname(final String value) throws IOException {
    return find(new HashMap<Enum, Object>(){{put(Person._Fields.firstname, value);}});
  }

  public Set<Person> findByLastname(final String value) throws IOException {
    return find(new HashMap<Enum, Object>(){{put(Person._Fields.lastname, value);}});
  }

  public Set<Person> findByType(final String value) throws IOException {
    return find(new HashMap<Enum, Object>(){{put(Person._Fields.type, value);}});
  }

  public Set<Person> findByCreatedAt(final Long value) throws IOException {
    return find(new HashMap<Enum, Object>(){{put(Person._Fields.created_at, value);}});
  }

  public Set<Person> findByUpdatedAt(final Long value) throws IOException {
    return find(new HashMap<Enum, Object>(){{put(Person._Fields.updated_at, value);}});
  }
}
